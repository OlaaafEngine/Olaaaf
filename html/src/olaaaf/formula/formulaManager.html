<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>src.olaaaf.formula.formulaManager API documentation</title>
<meta name="description" content="This class allows the user to easily declare a new `olaaaf.formula.formula.Formula` thanks to
`olaaaf.formula.formulaManager.FormulaManager.parser` …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.olaaaf.formula.formulaManager</code></h1>
</header>
<section id="section-intro">
<p>This class allows the user to easily declare a new <code>olaaaf.formula.formula.Formula</code> thanks to
<code>olaaaf.formula.formulaManager.FormulaManager.parser</code> and store in memory all previously named formulas,
either via their constructor or the function <code>olaaaf.formula.formulaManager.FormulaManager.declare</code>.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.olaaaf.formula.formulaManager.FormulaManager"><code class="flex name class">
<span>class <span class="ident">FormulaManager</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class compiling multiple tools used to declare any <code>olaaaf.formula.formula.Formula</code> in a more intuitive way.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FormulaManager():
    &#34;&#34;&#34;
    Class compiling multiple tools used to declare any `olaaaf.formula.formula.Formula` in a more intuitive way.
    &#34;&#34;&#34;

    #: A way to store all known and named `olaaaf.formula.formula.Formula` so they could be accessed again more easily.
    formulaDict: dict[str, Formula] = dict()

    @staticmethod
    def parser(string: str):
        &#39;&#39;&#39;
        Function allowing the user to intuitively parse a `olaaaf.formula.formula.Formula` from a string, using an infixed notation 
        and customizable operators.

        While more intuitive due to the less restrictive scope of usable operators, this method of declaring formulas assume you 
        previously named them, either via the `fmName` attribute in their constructor or thanks to `olaaaf.formula.formulaManager.FormulaManager.declare`.
        The operators could be customized in `olaaaf.constants.Constants` but are by default:\n

        * `&amp;` for the and operator, represented by `olaaaf.formula.naryFormula.andOperator.And`\n
        * `|` for the or operator, represented by `olaaaf.formula.naryFormula.orOperator.Or`\n
        * `~` for the not operator, represented by `olaaaf.formula.unaryFormula.notOperator.Not`\n
        * `-&gt;` for the implication operator, represented by `olaaaf.formula.binaryFormula.implicationOperator.Implication`\n
        * `&lt;-&gt;` for the equivalence operator, represented by `olaaaf.formula.binaryFormula.equivalenceOperator.Equivalence`\n
        * `&lt;+&gt;` for the xor operator, represented by `olaaaf.formula.binaryFormula.xorOperator.Xor`\n

        Attributes
        ----------
        string: String 
            The String to parse
        &#39;&#39;&#39;
        ParserElement.enablePackrat()
        
        formWord = Word(srange(&#34;[a-zA-Z_]&#34;), srange(&#34;[a-zA-Z0-9_:]&#34;))

        expr = infix_notation(formWord,
                              [(Literal(Constants.AND_PARSER_OPERATOR), 2, OpAssoc.LEFT),
                               (Literal(Constants.OR_PARSER_OPERATOR), 2, OpAssoc.LEFT),
                               (Literal(Constants.NOT_PARSER_OPERATOR), 1, OpAssoc.RIGHT),
                               (Literal(Constants.IMPLICATION_PARSER_OPERATOR), 2, OpAssoc.LEFT),
                               (Literal(Constants.XOR_PARSER_OPERATOR), 2, OpAssoc.LEFT),
                               (Literal(Constants.EQUIVALENCE_PARSER_OPERATOR), 2, OpAssoc.LEFT)],
                              lpar = &#34;(&#34;,
                              rpar = &#34;)&#34;)

        tokens = expr.parse_string(string)

        #return tokens
        return FormulaManager.__parserEvaluator(tokens)
    
    @staticmethod
    def __parserEvaluator(tokens: ParseResults) -&gt; Formula:
        
        if isinstance(tokens, ParseResults) or isinstance(tokens, list):

            if(len(tokens) == 1):
                return FormulaManager.__parserEvaluator(tokens[0])
            elif(len(tokens) == 2):
                if(tokens[0] == Constants.NOT_PARSER_OPERATOR):
                    from .unaryFormula.notOperator import Not
                    return Not(FormulaManager.__parserEvaluator(tokens[1]))
            elif(len(tokens) % 2 == 1):
                
                formulaType = None

                match tokens[1]:

                    case Constants.AND_PARSER_OPERATOR:
                        from .naryFormula.andOperator import And
                        formulaType = And
                    case Constants.OR_PARSER_OPERATOR:
                        from .naryFormula.orOperator import Or
                        formulaType = Or
                    case Constants.XOR_PARSER_OPERATOR:
                        from .binaryFormula.xorOperator import Xor
                        formulaType = Xor
                    case Constants.IMPLICATION_PARSER_OPERATOR:
                        from .binaryFormula.implicationOperator import Implication
                        formulaType = Implication
                    case Constants.EQUIVALENCE_PARSER_OPERATOR:
                        from .binaryFormula.equivalenceOperator import Equivalence
                        formulaType = Equivalence

                return formulaType(FormulaManager.__parserEvaluator(tokens[0]), FormulaManager.__parserEvaluator(tokens[2:]))

            else:
                raise TypeError(&#34;oop&#34;)
                
        elif isinstance(tokens, str):

            return FormulaManager.formulaDict[tokens]

    @staticmethod
    def declare(name: str, formula: Formula) -&gt; Formula:
        &#34;&#34;&#34;
        Function allowing the user to easily declare and name a new `olaaaf.formula.formula.Formula` for it to be stored in
        `olaaaf.formula.formulaManager.FormulaManager.formulaDict`.

        Attributes
        ----------
        name: String 
            The name of the `olaaaf.formula.formula.Formula` to declare.
            If the name is already in use, the old `olaaaf.formula.formula.Formula` will be forgotten and replaced by the newly declared one.\n
            For now, no restriction on the name is given but that should change in the near future.
        
            
        formula: `olaaaf.formula.formula.Formula`
            The `olaaaf.formula.formula.Formula` to declare and name.
        &#34;&#34;&#34;

        FormulaManager.formulaDict[name] = formula
        return formula</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="src.olaaaf.formula.formulaManager.FormulaManager.formulaDict"><code class="name">var <span class="ident">formulaDict</span> : dict[str, <a title="src.olaaaf.formula.formula.Formula" href="formula.html#src.olaaaf.formula.formula.Formula">Formula</a>]</code></dt>
<dd>
<div class="desc"><p>A way to store all known and named <code>olaaaf.formula.formula.Formula</code> so they could be accessed again more easily.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="src.olaaaf.formula.formulaManager.FormulaManager.declare"><code class="name flex">
<span>def <span class="ident">declare</span></span>(<span>name: str, formula: Formula) ‑> <a title="src.olaaaf.formula.formula.Formula" href="formula.html#src.olaaaf.formula.formula.Formula">Formula</a></span>
</code></dt>
<dd>
<div class="desc"><p>Function allowing the user to easily declare and name a new <code>olaaaf.formula.formula.Formula</code> for it to be stored in
<code>olaaaf.formula.formulaManager.FormulaManager.formulaDict</code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>String </code></dt>
<dd>
<p>The name of the <code>olaaaf.formula.formula.Formula</code> to declare.
If the name is already in use, the old <code>olaaaf.formula.formula.Formula</code> will be forgotten and replaced by the newly declared one.</p>
<p>For now, no restriction on the name is given but that should change in the near future.</p>
</dd>
<dt><strong><code>formula</code></strong> :&ensp;<code>olaaaf.formula.formula.Formula</code></dt>
<dd>The <code>olaaaf.formula.formula.Formula</code> to declare and name.</dd>
</dl></div>
</dd>
<dt id="src.olaaaf.formula.formulaManager.FormulaManager.parser"><code class="name flex">
<span>def <span class="ident">parser</span></span>(<span>string: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Function allowing the user to intuitively parse a <code>olaaaf.formula.formula.Formula</code> from a string, using an infixed notation
and customizable operators.</p>
<p>While more intuitive due to the less restrictive scope of usable operators, this method of declaring formulas assume you
previously named them, either via the <code>fmName</code> attribute in their constructor or thanks to <code>olaaaf.formula.formulaManager.FormulaManager.declare</code>.
The operators could be customized in <code>olaaaf.constants.Constants</code> but are by default:</p>
<ul>
<li>
<p><code>&amp;</code> for the and operator, represented by <code>olaaaf.formula.naryFormula.andOperator.And</code></p>
</li>
<li>
<p><code>|</code> for the or operator, represented by <code>olaaaf.formula.naryFormula.orOperator.Or</code></p>
</li>
<li>
<p><code>~</code> for the not operator, represented by <code>olaaaf.formula.unaryFormula.notOperator.Not</code></p>
</li>
<li>
<p><code>-&gt;</code> for the implication operator, represented by <code>olaaaf.formula.binaryFormula.implicationOperator.Implication</code></p>
</li>
<li>
<p><code>&lt;-&gt;</code> for the equivalence operator, represented by <code>olaaaf.formula.binaryFormula.equivalenceOperator.Equivalence</code></p>
</li>
<li>
<p><code>&lt;+&gt;</code> for the xor operator, represented by <code>olaaaf.formula.binaryFormula.xorOperator.Xor</code></p>
</li>
</ul>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>string</code></strong> :&ensp;<code>String </code></dt>
<dd>The String to parse</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.olaaaf.formula" href="index.html">src.olaaaf.formula</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.olaaaf.formula.formulaManager.FormulaManager" href="#src.olaaaf.formula.formulaManager.FormulaManager">FormulaManager</a></code></h4>
<ul class="">
<li><code><a title="src.olaaaf.formula.formulaManager.FormulaManager.declare" href="#src.olaaaf.formula.formulaManager.FormulaManager.declare">declare</a></code></li>
<li><code><a title="src.olaaaf.formula.formulaManager.FormulaManager.formulaDict" href="#src.olaaaf.formula.formulaManager.FormulaManager.formulaDict">formulaDict</a></code></li>
<li><code><a title="src.olaaaf.formula.formulaManager.FormulaManager.parser" href="#src.olaaaf.formula.formulaManager.FormulaManager.parser">parser</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
